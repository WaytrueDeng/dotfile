{"version":3,"sources":["index.js"],"names":["manageSettings","logseq","defaultSettings","expr","summaryTitle","keepRefs","nested","keepMeta","settingsVersion","pluginSettings","settings","updateSettings","main","summarizeExtracts","extracts","targetBlock","summaryBlock","Editor","insertBlock","uuid","sibling","forEach","i","content","slice","source","App","showMsg","processBlock","getExtracts","getBlock","currentBlock","includeChildren","RegExp","registerBlockContextMenuItem","length","registerPageMenuItem","pageBlocks","getPageBlocksTree","context","page","block","result","push","flat","regEx","children","currentBlockExtracts","matchAll","currentBlockExtractsWithBlockRef","map","e","c","ready","catch","console","error"],"mappings":";AAAA,SAASA,EAAeC,GAUhBC,IAAAA,EAAkB,CAClBC,KAAO,oCACPC,aAAc,UACdC,UAAU,EACVC,QAAQ,EACRC,UAAU,EACVC,gBAToB,MAapBC,EAAiBR,EAAOS,SAICD,EAAeD,iBAAmBN,EAAgBM,kBAK3EC,EAAiBP,EACjBD,EAAOU,eAAeF,IAI9B,SAASG,IAELZ,EAAeC,QAETQ,MAAAA,EAAiBR,OAAOS,SAK1BG,IAAAA,EAAoB,MAAOC,EAAUC,KAIjCC,IAAAA,QAAqBf,OAAOgB,OAAOC,YAAYH,EAAYI,KAAMV,EAAeL,aAAc,CAAEgB,SAAS,IAG7GN,EAASO,QAASC,IAEVC,IAAAA,EAAUD,EAAEC,QAGhBA,EAAUd,EAAeF,SAAWgB,EAAUA,EAAQC,MAAM,GAAI,GAGhED,EAAUd,EAAeJ,YAAckB,WAAiBD,EAAEG,OAAON,UAAYI,EAE7EtB,OAAOgB,OAAOC,YAAYF,EAAaG,KAAMI,EAAS,CAAEH,SAAS,MAGrEnB,OAAOyB,IAAIC,QAAQ,0CAGnBC,EAAe,MAAA,IAQXd,IAAAA,EAAW,GAGRA,OAFPe,QANoB5B,OAAOgB,OAAOa,SAASC,EAAaZ,KAAM,CAAEa,gBAAiBvB,EAAeH,SAClF,IAAI2B,OAAOxB,EAAeN,KAAM,KAKpBW,GAEnBA,GA4CXb,OAAOgB,OAAOiB,6BACV,UAzCgB,MAAA,IAEZpB,IAAAA,QAAiBc,EAAaG,GAG7BjB,GAAaA,EAASqB,OAM3BtB,EAAkBC,EAAUiB,GAJxB9B,OAAOyB,IAAIC,QAAQ,2BAsC3B1B,OAAOyB,IAAIU,qBACP,UA/Be,MAAA,IAEXC,IAAAA,QAAmBpC,OAAOgB,OAAOqB,kBAAkBC,EAAQC,MAC3D1B,EAAW,GAEV,IAAA,MAAM2B,KAASJ,EAAY,CAExBK,IAAAA,QAAed,EAAaa,GAC9BC,GAAU5B,EAAS6B,KAAKD,IAG9B5B,EAAWA,EAAS8B,SAGF9B,EAASqB,OAM3BtB,EAAkBC,EAAUuB,EAAWA,EAAWF,OAAS,IAJvDlC,OAAOyB,IAAIC,QAAQ,2BA4B/B,SAASE,EAAYE,EAAcc,EAAO/B,GAGlCgC,IAAAA,EAAWf,EAAae,SAGxBC,EAAuB,IAAIhB,EAAaR,QAAQyB,SAASH,IAGzDI,EAAmCF,EAAqBG,IAAKC,IAAe,CAAE5B,QAAS4B,EAAE,GAAI1B,OAAQM,KAGvGgB,EAAqBZ,QAAUrB,EAAS6B,QAAQM,GAGhDH,EAASX,QAAUW,EAASzB,QAAS+B,GAAMvB,EAAYuB,EAAGP,EAAO/B,IAKvEb,OAAOoD,MAAMzC,GAAM0C,MAAMC,QAAQC","file":"logseq-extract-plugin.97820166.js","sourceRoot":"..","sourcesContent":["function manageSettings(logseq) {\n\n    //Default settings - Extracts highlights and bold items\n    const highlightsRegEx = '(==[^=]+==)';\n    const boldRegEx = '(\\\\*\\\\*[^\\\\*]+\\\\*\\\\*)';\n\n    //CHANGE THIS WHEN ADDING NEW SETTINGS\n    const settingsVersion = 'v1';\n\n    //Use only for saving these first time in the plugin settings file\n    let defaultSettings = {\n        expr: `${highlightsRegEx}|${boldRegEx}`,\n        summaryTitle: 'Summary',\n        keepRefs: true,             //Keeps a reference to the source block in this format [*](((uuid)))\n        nested: true,                //Extract from current block and all the child blocks\n        keepMeta: false,              //Remove highlights and bold\n        settingsVersion: settingsVersion\n    };\n\n    //Load plugin settings\n    let pluginSettings = logseq.settings;\n\n    //This is to ensure that in future if new settings are added they are written over to settings file.\n    //This will overwrite user's existing settings though.\n    const shouldUpdateSettings = pluginSettings.settingsVersion != defaultSettings.settingsVersion;\n\n    //If first time, then save default settings\n    if (shouldUpdateSettings) {\n\n        pluginSettings = defaultSettings;\n        logseq.updateSettings(pluginSettings);\n    }\n}\n\nfunction main() {\n\n    manageSettings(logseq);\n\n    const pluginSettings = logseq.settings;\n\n    //targetBlock is the block under which the summary will be created.\n    //For block extract this will be immediately below the current block.\n    //For page extract it'll be the last block in the page.\n    var summarizeExtracts = async (extracts, targetBlock) => {\n\n        //Create a summary block below the current block (sibling) - you can change content of this block \n        //from Summary to something else by changing the summaryTitle property in settings\n        var summaryBlock = await logseq.Editor.insertBlock(targetBlock.uuid, pluginSettings.summaryTitle, { sibling: true });\n\n        //Create the extracts as children blocks of summary block\n        extracts.forEach((i) => {\n\n            let content = i.content;\n\n            //Remove == or ** from start and end if keepMeta is false\n            content = pluginSettings.keepMeta ? content : content.slice(2, -2);\n\n            //Keep reference of source block\n            content = pluginSettings.keepRefs ? `${content} [*](((${i.source.uuid})))` : content;\n\n            logseq.Editor.insertBlock(summaryBlock.uuid, content, { sibling: false });\n        });\n\n        logseq.App.showMsg('✔️ Extraction completed successfully!');\n    };\n\n    var processBlock = async (currentBlock) => {\n\n        //Get current block content\n        const block = await logseq.Editor.getBlock(currentBlock.uuid, { includeChildren: pluginSettings.nested });\n        const regEx = new RegExp(pluginSettings.expr, 'g');\n\n        //Get all extracts that match regex\n        //const extracts = [...block.content.matchAll(regEx)];\n        let extracts = [];\n        getExtracts(block, regEx, extracts);\n\n        return extracts;\n    }\n\n    //blockPipeline is the entry point when we extract at block level.\n    var blockPipeline = async (currentBlock) => {\n\n        let extracts = await processBlock(currentBlock);\n\n        //EXIT if no extracts found\n        if (!extracts || !extracts.length) {\n\n            logseq.App.showMsg('❗ Nothing to extract!');\n            return;\n        }\n\n        summarizeExtracts(extracts, currentBlock);\n    };\n\n    //blockPipeline is the entry point when we extract at page level.\n    var pagePipeline = async (context) => {\n\n        let pageBlocks = await logseq.Editor.getPageBlocksTree(context.page);\n        let extracts = [];\n\n        for (const block of pageBlocks) {\n\n            let result = await processBlock(block);\n            !!result && extracts.push(result);\n        }\n\n        extracts = extracts.flat();\n\n        //EXIT if no extracts found\n        if (!extracts || !extracts.length) {\n\n            logseq.App.showMsg('❗ Nothing to extract!');\n            return;\n        }\n\n        summarizeExtracts(extracts, pageBlocks[pageBlocks.length - 1]);\n    }\n\n\n    //Extraction function which registers Extract as a context menu for a block\n    logseq.Editor.registerBlockContextMenuItem(\n        'Extract', blockPipeline\n    );\n\n    //Extraction function which registers Extract as a context menu for a block\n    logseq.App.registerPageMenuItem(\n        'Extract', pagePipeline\n    );\n    // logseq.App.registerPageMenuItem(\n    //     'Extract', async (context) => {\n\n    //         let pageBlocks = await logseq.Editor.getPageBlocksTree(context.page);\n    //         pageBlocks.forEach((block) => processBlock(block));\n    //     }\n    // );\n\n\n}\n\nfunction getExtracts(currentBlock, regEx, extracts) {\n\n    //Get children of the current block\n    let children = currentBlock.children;\n\n    //Find the extracts from the current block\n    let currentBlockExtracts = [...currentBlock.content.matchAll(regEx)];\n\n    //Create a map from current block's extracts\n    let currentBlockExtractsWithBlockRef = currentBlockExtracts.map((e) => { return { content: e[0], source: currentBlock }; });\n\n    //Push the extracts map from current block into main extracts array\n    !!currentBlockExtracts.length && extracts.push(...currentBlockExtractsWithBlockRef);\n\n    //If there are children then call this method recursively (filling the main extracts array which is passed as argument)\n    !!children.length && children.forEach((c) => getExtracts(c, regEx, extracts));\n    return;\n}\n\n// bootstrap\nlogseq.ready(main).catch(console.error)"]}